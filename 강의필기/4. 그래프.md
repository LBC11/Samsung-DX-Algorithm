## 그래프

### 그래프 기본
- 그래프는 아이템들과 이들 사이의 연결 관계를 표현한다.
- 그래프는 정점(vertex, |V|)들의 집합과 이들을 연결하는 간선(edge, |E|)들의 집합으로 구성된 자료구조
    + 정점의 개수가 n일 때 최대 간선의 개수는 n*(n-1)/2이다.
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 표현하기에 용이하다.

### 그래프 유형
1. 무향 그래프(Undirected Graph): 방향성이 없음 그래서 양 방향으로 둘다 이동 가능
2. 유향 그래프(Directed Graph): 방향성 존재
3. 가중치 그래프(Weighted Graph): 각 간선에 가중치(cost)를 표현하는 숫자 존재
4. 사이클 없는 방향 그래프(DAG, Directed Acynllc Graph): A에서 나가서 다시 A로 돌아올수 없음.
5. 완전 그래프: 정점들에 대해 가능한 모든 간선을을 가진 그래프
6. 부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

### 인접
- 두개의 정점에 간선이 존재(연결됨)
- 완전 그래프의 경우 임의의 두 정점들은 모두 인접해 있다. 

### 그래프 경로
- 경로: 간선들을 순서대로 나열한 것
    + 간선들: (0,2), (2,4), (4,6)
    + 정점들: 0-2-4-6
- 단순경로: 경로 중 한 정점을 최대한 한번만 지나는 경로
- 사이클(Cycle) 시작한 정점에서 끝나는 경로

### 그래프 표현
간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정

- 인접 행렬(Adjacent matrix): |V| * |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
- 인접 리스트(Adjacent List): 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
- 간선의 배열: 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

### 인접 행렬
두 정점을 연결하는 간선의 유무를 행렬로 표현 (DFS 탐색시 O(n^2))

- |V| * |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
- 무향 그래프
    + i번쨰 행의 합 = i번째 열의 합 = Vi의 차수
- 유향 그래프
    + 행 i의 합 = Vi의 진출 차수
    + 열 i의 합 = Vi의 진입 차수

장점: 인접 여부 확인이 index을 통해 빠르게 가능하다. O(1)
단점: 간선이 존재하는지 않는 것도 표현하기 위해 메모리를 할당하기에 낭비되는 memory가 있다.

### 인접 리스트
- 각 정점에 대한 인접 정점들을 순차적으로 표현 (DFS 탐색시 O(|V| + |E|))
- 하나의 정점에 대한 인접 정정들을 각각 노드로 하는 연결 리스트로 저장
- 무향 그래프
    + 노드 수  = 간선의 수 * 2
    + 각 정점의 노드 수  = 정점의 차수
- 유향 그래프
    + 노드 수  = 간선의 수
    + 각 정점의 노드 수  = 정점의 진출 차수

장점: memory 사용이 적다
단점: 인접 여부 확인을 위해서 일일이 반복문을 통해 살펴봐야 한다. O(n)

### Stack의 특성
- 삽입과 삭제의 위치가 제한적인 자료구조
- 후입선출구조, LIFO

### DFS(Depth First Search)
- 시작 정점의 한방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정멎으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

### 재귀를 통한 DFS구현
```

int[MAX_N][MAX_N] Graph;
boolean[MAX_N] visited;

void dfs(int node) {
    visited[node] = true;

    for(int next=0; next<N; ++next) {
        if(!visited[next] && Graph[node][next]) 
            dfs(next);
    }
}

```

### 반복를 통한 DFS구현
- input size가 클 때 재귀를 사용하면 stack overflow가 발생할 수 있으니 이렇게 반복을 통해서 사용해라
```

int[MAX_N][MAX_N] Graph;
int[STACK_SIZE] Stack, Top;
void dfs(int node) {

    boolean[MAX_N] visited = { false };
    Top = -1;
    Stack[++Top] = node;
    while(Top != -1) {
        int curr = Stack[Top--];
        if(!visited[curr]) {
            // 방문 표시
            visited[curr] = true;
            
            for(int next = 0; next < N; ++next) {
            
            // 첫번째 조건은 방문했는지 여부 두번째 조건은 두 정점이 인접했는지 여부
            if(!visited[next] && Graph[curr][next])
                Stack[++Top] = next;
            }
        }
    }
}

```

### Queue의 특성
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
- 선입선출구조, FIFO

### BFS(Breadth First Search)
- 너비 우선 탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문 했던 정점을 시작점으로 하여 다시 인저반 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비 우선 탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 queue를 활용함
- DFS 와 logic은 같음, but 자료구조를 stack(LIFO)을 사용하냐 queue(FIFO)을 사용하냐 차이다.

### 반복문을 통한 BFS구현
```

int Graph[MAX_N][MAX_N];
int Queue[QUEUE_SIZE], Front, Rear;

void bfs(int node) {
    boolean visited[MAX_N] = {false};
    Front = Rear = -1;
    Queue[++Rear] = node;
    while(Front != Rear) {
        int curr = Queue[++Front];
        if(!visited[curr]) {
            visited[curr] = true;

            for(int next = 0; next< N; ++next) {
                if(!visited[next] && Graph[curr][next]) {
                    Queue[++Rear] = next;
                }
            }
        }
    }
}

```

### BFS구현 - Queue를 덜 사용하도록 개선
```

int Graph[MAX_N][MAX_N];
int Queue[QUEUE_SIZE], Front, Rear;

void bfs(int node) {
    boolean visited[MAX_N] = {false};
    Front = Rear = -1;
    visited[node] = true;
    Queue[++Rear] = node;
    while(Front != Rear) {
        int curr = Queue[++Front];

        for(int next = 0; next< N; ++next) {
            if(!visited[next] && Graph[curr][next]) {
            
                // queue에 삽입하기 전에 true라고 표시
                // 이러면 queue에 중복되는 정점이 insert되는
                // 것을 방지할 수 있다.
                 
                // DFS에서는 stack이 LIFO이므로 먼저 넣은 
                // 정점이 먼저 방문된다는 보장이 없기 때문에 
                // 이렇게 하지 못했다.
                visited[next] = true;
                Queue[++Rear] = next;
            }
        }
    }
}

```

### BFS구현 - Queue를 덜 사용하도록 개선 + 가중치가 없는 그래프에서 BFS로 최단 경로 구하기
```

int Graph[MAX_N][MAX_N], Dist[Max_N];
int Queue[QUEUE_SIZE], Front, Rear;

void bfs(int node) {
    boolean visited[MAX_N] = {false};
    
    Dist[node] = 0;
    
    Front = Rear = -1;
    visited[node] = true;
    Queue[++Rear] = node;
    while(Front != Rear) {
        int curr = Queue[++Front];

        for(int next = 0; next< N; ++next) {
            if(!visited[next] && Graph[curr][next]) {
            
                // queue에 삽입하기 전에 true라고 표시
                // 이러면 queue에 중복되는 정점이 insert되는
                // 것을 방지할 수 있다.
                 
                // DFS에서는 stack이 LIFO이므로 먼저 넣은 
                // 정점이 먼저 방문된다는 보장이 없기 때문에 
                // 이렇게 하지 못했다.
                visited[next] = true;
                
                Dist[next] = Dist[curr] + 1;
                
                Queue[++Rear] = next;
            }
        }
    }
}

```
