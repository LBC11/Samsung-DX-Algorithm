## 그리디
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방시긍로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 그래서 지역적으로 최적인 해가 최종적으로 최적인 것이라는 정당성 증명이 중요하다.

### 그디리 알고리즘 필요 조건
1. 탐욕적 선택 속성(Greedy choice property)
    - 탐욕적 선택은 최적 해로 갈수 있어야 한다.
    - 탐욕적 선택은 항상 안전해야 한다.
2. 최적 부분 구조(Optimal substructure property)
    - 최적화 문제를 정형화 해야한다.
    - 나나의 선택을 하면 풀어야 할 하나의 하위 문제가 남아야 한다.

### 문제 제시: 거스름돈 줄이기
- 손님이 지불한 금액에서 물건값을 제한 차액을 지불하는 문제를 생각해보자
- 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?
- 배낭문제(0-1 knapsack)과 같이 그리디를 통해 최적해를 구한다는 보장이 없다!!!

### 배낭 문제(knapsack)
- 0-1 knapsack: 물건을 쪼개서 팔 수 없는 경우, 그리디로 풀리지 않음.
- Fractional Knapsack: 물건을 쪼개서 파는 경우, 그리디로 해결 가능

### 그리디 알고리즘이 유용한 문제
- 회의실 배정하기(활동 선택 문제 유형)
  + 김대리는 SW 개발팀들의 회의실 사용 신청을 처리하는 업무를 한다. 이번 주 금요일에 가능한 회의실은 하나만 존재하고 다수의 회의가 신청된 상태이다.
  + 회의는 시작 시간과 종료 시간이 있으며, 회의 시간이 겹치는 회의들은 동시에 열릴 수 없다.
  + 최대 몇개의 회의를 배정할 수 있을까? 
- 탐욕 기법의 적용
  1. 회의 목록 S에서 가장 일찍 끝나는 회의 a을 선택한다.
  2. a와 겹치는 모든 회의를 S에서 삭제한다.
  3. S에 회의가 모두 없어질 때까지, 1번부터 반복한다.
- 정당성 증명
  1. 탐욕적 선택이 항상 최적해로 가는 길 중에 하나이다.
  2. 가장 종료 시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.

```

struct meeting_type {
    int start;
    int end;
}

int N;
meeting_type Meetings[10];

int solve() {

  // 선택 정렬
  for(int i=0; i<N-1; ++i) {
      for(int j= i+1; j<N; ++j) {
          if(Mettings[i].end > Meetings[j].end) {
              meeting_type tmp = Meetings[i];
              Meetings[i] = Meetings[j];
              Meetings[j] = tmp;
          }
      }
  }

  int lastEnd = 0, cnt = 0;
  for(int i=0; i<N; ++i) {
      if(Meetings[i].start <lastEnd) continue;

      prinf("($d,$d)\n", Meetings[i].start, Meetings[i].end);
      lastEnd = Meetings[i].end;
      ++cnt;
  }

  return cnt;
}

int main() {
    freopen("meeting_input.txt", "r", stdin);

    cin >> N;
    for(int i=0; i<N; ++i) {
        cin >> Meetings[i].start >> Meetings[i].end;
    }

    cout << solve() <<endl;

    return 0;
}

```

- Baby-gin
  + 3, 4, 5와 같이 연속된 세 수가 1 차이로 등차일 경우를 Run이라 칭하고, 7, 7, 7와 같이 같은 수가 세 번 연속된 수를 Triplet이라고 한다. 
  + 여섯개의 숫자 중, 3개는 Run, 3개는 Triplet을 이룰 때 Baby Gin이라고 한다. 여섯 개의 수가 주어졌을 때 Baby Gin임을 판별하는 알고리즘을 작성하시오.

  + 완전 검색으로도 풀리지만 그리디로도 풀어보자
  + 0~9 번호별 카드의 개수를 counts 배열에 센다.
  + counts 배열의 각 원소를 체크하여 run과 triplet를 확인하여 baby-gin 여부를 판단한다.


### 풀이
<img src="https://user-images.githubusercontent.com/107410759/216268006-e704a4f0-12fd-47b8-a27f-00f9a98d5d54.png" width="800" height="400"/>
사실 run을 triplet 보다 먼저 확인하면 error가 날 수 있으니 triple을 먼저 조사해야 한다.

```

int solve() {
    int tri = 0, run = 0;
    for(int i=0; i<10;) {
    
        // triple 먼저 확인
        if(Cnt[i] >= 3) {
            Cnt[i] -= 3;
            tri++;
        }
        
        // run 확인
        else if(i<= 7 && Cnt[i] >= 1 && Cnt[i+1] >= 1 && Cnt[i+2] >= 1) {
            Cnt[i]--;
            Cnt[i+1]--;
            Cnt[i+2]--;
            run++;
        }
        else {
            i++;
        }
    }

    if(tri + run == 2) {
        return 1;
    }
    return 0;
}

```
