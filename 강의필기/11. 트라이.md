## Trie
- 문자열의 집합을 표현하는 Tree
- 정보검색(Retrieval)에서 이름을 따옴

<img src="https://user-images.githubusercontent.com/107410759/216622749-9150d51b-dc1d-4b5a-8ce8-6355dd17c248.png" width="400" height="300"/>
- 트라이의 각 간선은 하나의 문자에 대응
- 같은 node에서 나온 edge들은 같은 라벨을 갖지 않음
- 루트에서 단말 노드까지 이른 경로는 하나의 문자열

### 접미어 트라이
- 문자열의 모든 접미어를 Trie로 표현함
- 모든 문자열은 다른 문자열의 접두어가 아니라고 가정한다.
- ex. "abac"에 대한 모든 접미어를 표현한 trie
<img src="https://user-images.githubusercontent.com/107410759/216627948-ecaea7b3-1506-458e-b08a-08900b2ba20d.png" width="400" height="300"/>

### 접미어 트라이를 이용한 문자열 연산 
- 부분 문자열 검사: "ba"가 "abcd"의 부분 문자열인가?
    + 방법: 한 문자씩 루트에서 대응되는 간선 따라가기
- 두 접미어의 최장 공통 접두어 찾기: "abcd"와 "ac"의 최장 공통 접두어는 무엇인가?
    + 방법
        1. 두 접미어의 끝 글자에 대응하는 node(leaf node) 선택
        2. 가장 가까운 공통 조상 찾기
        3. 공통 접두어 만들기
- 사전적 순서로 정렬된 k번쨰 접미어 찾기: "abcd"에서 사전적 순서로 3번째 접미어는 무엇인가?
    + 방법
        1. 트라이를 깊이 우선 탐색으로 문자열을 생성하면 사전적 순서로 정렬된다.
        2. 생성된 문자열을 메모리에 저장하지 않고 인덱스 값만 저장함  

이해가 잘 안되서 첨부  
<img src="https://user-images.githubusercontent.com/107410759/216626363-524f7bd0-8a8b-4334-8b05-e39c098f13e6.png" width="600" height="450"/>

### Compressed Trie
<img src="https://user-images.githubusercontent.com/107410759/216636975-375e6203-d7e9-4eb2-a7eb-7aafa3fb9674.png" width="600" height="450"/>

### 접미어 트리(Suffix Tree)
- 하나의 문자열의 모든 접미어들을 포함하는 트라이의 압축된 표현
- 공간 복잡도를 줄이기 위헤 접미어 배열을 사용한다.
- 문자열 연산에 필요한 알고리즘을 빠르게 구현할 수 있다.
- 전체 생성하는 데 걸리는 시간: O(n^2)
- 길이 s인 문자열 S의 suffic tree의 속성
    1. 1부터 s까지 번호가 부여된 s개의 잎노드를 가진다.
    2. 루트를 제외한 내부 노드들은 최소 2개의 자식을 가진다.
    3. 각 간선은 문자열 S의 부분문자열 라벨이 부여된다.
    4. 한 노드에서 나가는 두 개의 간선이 동일한 문자로 시작하는 문자열 라벨을 가질 수 었다.
    5. 루트로부터 잎노드 i까지 경로에서 존재하는 문자열 라벨들이 연결된 문자열을 Suffix S[i...s], for i = 1,...,S라고 한다.


<img src="https://user-images.githubusercontent.com/107410759/216638669-9dec57fe-7bd6-48e1-b3de-bdc8eddc4af9.png" width="600" height="450"/>

<img src="https://user-images.githubusercontent.com/107410759/216638836-2190fd0f-007b-4e43-80a1-105ee58f947b.png" width="600" height="450"/>
- 하나의 접미어가 다른 접미어의 접두어가 되는 경우를 표현하기 위해 문자열 S의 끝에 특수한 문자($)fmf cnrkgksek.
    + $를 종료 문자라고 부르고 가장 작은 값을 가지는 문자이다.
- 간선 라벨을 효과적으로 저장하기 위해 부분 문자열 T[i...j]의 인덱스 시작과 끝[i,j]을 저장할 수 있다.

<img src="https://user-images.githubusercontent.com/107410759/216639341-7df503f5-8945-43b0-bfe8-6745d5887bec.png" width="600" height="450"/>

### 접미어 배열
- 접미어 트리보다 메모리를 좀 더 효율적으로 사용하지만 다소 느리다.
- 메모리 크기: O(n)
- 시간 복잡도: O(nlogn)
- 텍스트 T에 패턴 P의 존재를 O(|P|+logn)시간에 계산한다.
- 장점
    + 생성 방법이 접미어 트리에 비해 간단하다
    + 적은 메모리로 구현 가능하다. 일반적으로 접미어 트리에 비해 1/4만을 사용한다.
<img src="https://user-images.githubusercontent.com/107410759/216640237-5a967a70-c894-420d-a57e-039d67cb8f22.png" width="300" height="200"/>

### LCP 배열
- 접미어 배열의 보조적인 자료 구조로 최장 공통 접두어(LCP, Longest Common Prefix) 배열.
- LCP 배열은 정렬된 접미어 배열에서 연속적인 2개의 접미어들 사이의 최장 공통 접두어의 길이를 저장한다.
- 접미어 배열의 순회나 패턴 매칭을 효율적으로 수행하는 데 사용된다.

- 여러 개의 접미사 중 사전 순으로 가장 앞서는 문자열을 찾는 문제
- 최장공통접두사의 길이나 문자열을 찾는 문제
- 문자열 내에서 반복적으로 나오는 문자열 검색 문제  
등에 사용될 수 있다.






