## DP
- 완전검색을 하는데 좀 스마트하게 하는 방법
- Recursive + Memoization 
- 점화식으로 표현 가능

### 문제: 토끼 수 구하기(피보나치 수열)
<img src="https://user-images.githubusercontent.com/107410759/216056810-db599b5a-00e0-4c8b-987d-ed0baad51723.png" width="400" height="200"/>

=> 점화식으로 표현하면 f(n+@) = f(n+1) + f(n) 이 나온다.

### 비둘기 집의 원리
- n+1 개의 비둘기를 n개의 집에 보관하려면 적어도 한 개의 집에서 비둘기를 2마리 이상 보관해야 한다는 원리
- 위의 사실과 n번째의 fibo()함수 값을 구하기 위해 2^(n/2)번 호출해야 한다는 사실을 통해 같은 연산이 중복해서 호출되고 있음을 알수 있다.

### 연습문제 1
<img src="https://user-images.githubusercontent.com/107410759/216058577-02a243a2-f18f-4ad0-b840-01810a38043e.png" width="600" height="330"/>


점화식 표현  
<img src="https://user-images.githubusercontent.com/107410759/216059314-7eba8ee4-857b-4946-967b-56dc8d578307.png" width="600" height="300"/>

```

dp[1][0] = dp[1][1] = 1

for(int i=2; i<=n; i++) {
  dp[i][0] = dp[i-1][0] + dp[i-1][1]; // 노랑
  dp[i][1] = dp[i-1][1]  // 파랑
}

정답: dp[n][0] + dp[n][1];

```

### Memoization
- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. DP의 핵심이 되는 기술이다.
- memoization 은 글자 그대로 해석하면 메모리에 넣기(to put in memory) 라는 의미이며 '기억되어야 할것' 이라는 뜻의 라틴어 memorandum에서 파생되었다. memorization과 혼동하지만, 정확한 단어는 memoization이다. 동사형은 memoize이다.
- 실행시간을 O(n)으로 줄일 수 있다.
- 단점: 추가적인 메모리 공간이 필요하여 많이 계산할 때 실행 속도 저하 또는 오버플로우가 발생할 수 있다.

### 동적 계획 알고리즘
- DP는 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 최적화 문제: 최적(최댓값 혹은 최솟값)값을 구하는 문제
- DP는 먼저 작은 부분 문제들의 해들을 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법이다.

### DP 적용 요건
- 최적 부분문제 구조(Optimal substructure)
- 중복 부분문제 구조(Overlapping subproblems)

### 최적 부분문제 구조(Optimal substructure)
- 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아니다. 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.
- 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다. 도적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하기 때문에 만약 큰 문제의 최적해가 작은 문제들의 최적화의 해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다.

### 중복 부분문제 구조(Overlapping subproblems)
- DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다.
- 순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 수학적 도구인 점화식을 사용한다.
- DP는 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데(Overlapping subproblems) 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간에 저장하게 된다. 
- 그리고 이렇게 저장된 해들이 다시 필요할 떄마다 해를 얻기 위해 다시 문제를 재계산하지 않고 table의 참조를 통해서 중복된 계싼을 피하게 된다.

### 분할 정복과 동적 계획법의 비교
- 분할 정보
    + 연관 없는 부분 문제로 분할 한다.
    + 부분문제를 독립, 재귀적으로 해결한다.
    + 부분 문제의 해를 결합(combine)한다.
    + 하향식 접근

- DP
    + 부분문제들이 연관이 없으면 적용할 수 없다. 즉 부분문제들은 더 작은 부분 문제들을 공유한다.
    + 모든 부분문제를 한번만 계산하고 결과를 저장하고 재사용한다.
    + 분할 정복은 같은 부분문제가 나타날 경우 다시 계산한다.
    + 상향식 접근(but, 하향식으로 구현이 가능하다, TSP문제)

### DP 적용 접근 방법
1. 최적해 구조의 특성을 파악하라.
    - 문제를 부분 문제로 나눈다.
2. 최적해의 값을 재귀적으로 정의하라
    - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다.
4. 상향식 방법으로 최적해의 값을 계산하라
    - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다.
    - 저장된 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다.

### DP를 사용하는 이유
- 재귀 알고리즘과는 달리 중복 계산이 없다.
- 반복문을 사용하기에 함수 호출이 발생하지 않는다.
- O(n)

### 문제: 계수 값  
<img src="https://user-images.githubusercontent.com/107410759/216069321-e64033ef-8323-416a-951f-e76670cbc02e.png" width="400" height="200"/>
=> 구체적으로 각 n단계에서 x 와 y 둘 중 하나를 고르는 선택지에서 k개를 고르는 결과와 같다. nCk

<img src="https://user-images.githubusercontent.com/107410759/216070618-785574fb-c91e-4eb6-951a-6a63a29d3cf9.png" width="800" height="600"/>

### 재귀를 이용한 계산
```

bino(n, k) {
    if(k=0 || n=k)
        return 1;
    else
        return bino(n-1, k-1) + bino(n-1,k)
}

```

### 재귀 + DP를 이용한 계산
```

int[][] B = {-1};
bino(n, r) {
    if(r=0 || n=r) return 1;
    if(B[n][r] != -1) return B[n][r]
    
    B[n][r] = bino(n-1, r-1) + bino(n-1,r);
    return B[n][r]
}

```    

### 반복 + DP를 이용한 계산
```

bino(n, k) {
    
    int[][] B = {-1};
    for(int i=0; i < n; i++) {
        for(int j=0; j<Math.min(i,k); j++ {
            if(j=0 || j=i) B[i][j] = 1
            else B[i][j] = B[i-1][j-1] + B[i-1][j]
        }
    }
    
    return B[n][k]
}

```  




