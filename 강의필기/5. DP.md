## DP
- 완전검색을 하는데 좀 스마트하게 하는 방법
- Recursive + Memoization 
- 점화식으로 표현 가능

### 문제: 토끼 수 구하기(피보나치 수열)
<img src="https://user-images.githubusercontent.com/107410759/216056810-db599b5a-00e0-4c8b-987d-ed0baad51723.png" width="400" height="200"/>

=> 점화식으로 표현하면 f(n+@) = f(n+1) + f(n) 이 나온다.

### 비둘기 집의 원리
- n+1 개의 비둘기를 n개의 집에 보관하려면 적어도 한 개의 집에서 비둘기를 2마리 이상 보관해야 한다는 원리
- 위의 사실과 n번째의 fibo()함수 값을 구하기 위해 2^(n/2)번 호출해야 한다는 사실을 통해 같은 연산이 중복해서 호출되고 있음을 알수 있다.

### 연습문제 1
<img src="https://user-images.githubusercontent.com/107410759/216058577-02a243a2-f18f-4ad0-b840-01810a38043e.png" width="600" height="330"/>


점화식 표현  
<img src="https://user-images.githubusercontent.com/107410759/216059314-7eba8ee4-857b-4946-967b-56dc8d578307.png" width="600" height="300"/>

```

dp[1][0] = dp[1][1] = 1

for(int i=2; i<=n; i++) {
  dp[i][0] = dp[i-1][0] + dp[i-1][1]; // 노랑
  dp[i][1] = dp[i-1][1]  // 파랑
}

정답: dp[n][0] + dp[n][1];

```

### Memoization
- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. DP의 핵심이 되는 기술이다.
- memoization 은 글자 그대로 해석하면 메모리에 넣기(to put in memory) 라는 의미이며 '기억되어야 할것' 이라는 뜻의 라틴어 memorandum에서 파생되었다. memorization과 혼동하지만, 정확한 단어는 memoization이다. 동사형은 memoize이다.
- 실행시간을 O(n)으로 줄일 수 있다.
- 단점: 추가적인 메모리 공간이 필요하여 많이 계산할 때 실행 속도 저하 또는 오버플로우가 발생할 수 있다.

### 동적 계획 알고리즘
- DP는 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 최적화 문제: 최적(최댓값 혹은 최솟값)값을 구하는 문제
- DP는 먼저 작은 부분 문제들의 해들을 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법이다.

### DP 적용 요건
- 최적 부분문제 구조(Optimal substructure)
- 중복 부분문제 구조(Overlapping subproblems)

### 최적 부분문제 구조(Optimal substructure)
- 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아니다. 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.
- 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다. 도적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하기 때문에 만약 큰 문제의 최적해가 작은 문제들의 최적화의 해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다.

### 중복 부분문제 구조(Overlapping subproblems)
- DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다.
- 순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 수학적 도구인 점화식을 사용한다.
- DP는 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데(Overlapping subproblems) 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간에 저장하게 된다. 
- 그리고 이렇게 저장된 해들이 다시 필요할 떄마다 해를 얻기 위해 다시 문제를 재계산하지 않고 table의 참조를 통해서 중복된 계싼을 피하게 된다.

### 분할 정복과 동적 계획법의 비교
- 분할 정보
    + 연관 없는 부분 문제로 분할 한다.
    + 부분문제를 독립, 재귀적으로 해결한다.
    + 부분 문제의 해를 결합(combine)한다.
    + 하향식 접근

- DP
    + 부분문제들이 연관이 없으면 적용할 수 없다. 즉 부분문제들은 더 작은 부분 문제들을 공유한다.
    + 모든 부분문제를 한번만 계산하고 결과를 저장하고 재사용한다.
    + 분할 정복은 같은 부분문제가 나타날 경우 다시 계산한다.
    + 상향식 접근(but, 하향식으로 구현이 가능하다, TSP문제)

### DP 적용 접근 방법
1. 최적해 구조의 특성을 파악하라.
    - 문제를 부분 문제로 나눈다.
2. 최적해의 값을 재귀적으로 정의하라
    - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다.
4. 상향식 방법으로 최적해의 값을 계산하라
    - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다.
    - 저장된 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다.

### DP를 사용하는 이유
- 재귀 알고리즘과는 달리 중복 계산이 없다.
- 반복문을 사용하기에 함수 호출이 발생하지 않는다.
- O(n)

### 문제: 계수 값  
<img src="https://user-images.githubusercontent.com/107410759/216069321-e64033ef-8323-416a-951f-e76670cbc02e.png" width="400" height="200"/>
=> 구체적으로 각 n단계에서 x 와 y 둘 중 하나를 고르는 선택지에서 k개를 고르는 결과와 같다. nCk

<img src="https://user-images.githubusercontent.com/107410759/216070618-785574fb-c91e-4eb6-951a-6a63a29d3cf9.png" width="800" height="600"/>

### 재귀를 이용한 계산
```

bino(n, k) {
    if(k=0 || n=k)
        return 1;
    else
        return bino(n-1, k-1) + bino(n-1,k)
}

```

### 재귀 + DP를 이용한 계산
```

int[][] B = {-1};
bino(n, r) {
    if(r=0 || n=r) return 1;
    if(B[n][r] != -1) return B[n][r]
    
    B[n][r] = bino(n-1, r-1) + bino(n-1,r);
    return B[n][r]
}

```    

### 반복 + DP를 이용한 계산
```

bino(n, k) {
    
    int[][] B = {-1};
    for(int i=0; i < n; i++) {
        for(int j=0; j<Math.min(i,k); j++ {
            if(j=0 || j=i) B[i][j] = 1
            else B[i][j] = B[i-1][j-1] + B[i-1][j]
        }
    }
    
    return B[n][k]
}

```  

## 계산 복잡도 이론
1. Automata Theory: FA/ PDA/ TM
2. Computational Theory
3. Computational Complexity Theory: P/ NP/ NPC

### P-NP
- 다루기 힘든 정도(Intractability)
    + 다차시간 알고리즘을 찾을 수 없는 문제
- 문제의 분류
    + 다차시간 알고리즘을 찾은 문제 (P) ex. 정렬 문제
    + 다루기 힘들다고 증명된 문제
    + 다루기 힘들다고 증면되지는 않았고, 다차시간 알고리즘도 찾지 못한 문제 (NP)
- P(Polynomail): 다차시간 알고리즘이 존재하는 모든 결정 문제들의 집합, 다항식의 시간복잡도를 가진 문제
- NP(Nondeterministic Polynomial): 다차시간 비결정적 알고리즘으로 해결할 수 있는 모든 결정 문제의 집합, 다항식의 시간복잡도로 풀리지 않는 문제 ex. 2^n 같은 지수식

- 결정적 알고리즘
    + 결과가 유일하게 정의된 연산만을 써서 만들어진 알고리즘
    + 우리가 지금까지 작성하는 모든 알고리즘
- 비결정적 알고리즘
    + 연산 결과가 상황에 따라 달라질 수 있는 연산을 써서 만들어진 알고리즘
    + 추측(비결정적; nondeterministic) 단계
    + 검증(결정적; deterministic, verificaiton) 단계

### 다차시간 알고리즘을 찾은 문제
<img src="https://user-images.githubusercontent.com/107410759/216225264-a96cd0c6-f5de-4923-89a0-267815ff87a4.png" width="800" height="500"/>

### 다루기 힘들다고 증명된 문제
<img src="https://user-images.githubusercontent.com/107410759/216225521-f6e26e4e-22fe-4f7b-bc04-0a4c6c747306.png" width="800" height="500"/>

### 다루기 힘들다고 증명되지 않았고, 다차시간 알고리즘도 찾지 못한 문제
<img src="https://user-images.githubusercontent.com/107410759/216225786-a746face-0882-45ef-ad0f-01a158dd149d.png" width="800" height="300"/>

### 최적화 문제 vs 결정 문제
<img src="https://user-images.githubusercontent.com/107410759/216226136-f8057a02-3aed-4699-a471-9aeb243ff258.png" width="800" height="400"/>

### 다항식 시간 변환
<img src="https://user-images.githubusercontent.com/107410759/216227232-7121258a-97b2-4fe1-8362-fef944ee92eb.png" width="600" height="300"/>
-> A to B의 변환이 다항식 시간에 이루어지고 두 사례의 답이 일치하면 A도 쉽다.

<img src="https://user-images.githubusercontent.com/107410759/216227907-46b70a5d-ae0e-4b14-97ba-0a5e29f2b278.png" width="800" height="600"/>

<img src="https://user-images.githubusercontent.com/107410759/216228021-001c47af-6fe1-4827-b52f-4d132c981dc3.png" width="800" height="600"/>

<img src="https://user-images.githubusercontent.com/107410759/216228376-bfb9fa1b-96e1-4fb6-93b1-5608bdc7b176.png" width="300" height="100"/>
- NP-complete 문제는 NP-hard 문제이면서 동시에 NP 문제이다.
- 문제 A가 NP-complete 문제가 되려면
    1. 문제 A는 NP 문제이고, 동시에
    2. 문제 A는 NP-hard 문제이다. 

### NP 이론의 유용성
- 어떤 문제가 NP-complete/hard임이 확인되면 쉬운 알고리즘을 찾으려는 헛된 노력은 중지하고 주어진 시간 예산 내에서 최대한 좋은 해를 찾는 알고리즘(heuristic, 근사해) 개발에 집중하자

### NP-complete 문제들
- SAT(Satisfiability)
    + Boolean 변수들이 OR로 표현된 논리식이 여러 개 주어질 떄, 이 논리식들을 모두 만족시키는 각 Boolean 변수의 값을 찾는 문제
- 부분 집합의 합(Subset Sum)
    + 주어진 정수의 집합 S를 분할하여 원소의 합이 같은 2개의 부분 집합을 찾는 문제
- 분할(Partition)
    + N개의 수가 있을 떄 이 중 몇 개를 골라내서 그들의 합이 S가 되도록 할 수 있는가?
- 0-1 배낭(Knapsack)
    + 한 여행가가 가지고 가는 배낭에 담을 수 있는 무게의 최댓값이 정해져 있고, 일정 가치와 무게가 있는 짐들을 배낭에 넣을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제
- 정점 커버(Vertex Cover)
    + 주어진 그래프에서 각 선분의 양 끝점들 중에서 적어도 1개의 점을 포함하는 집합. 정점 커버 문제는 최소 크기의 정점 커버를 찾는 문제이다.
- 독립 집합(Independence Set)
    + 주어진 그래프에서 연결하는 선분이 없는 점들의 집합. 독립 집합 문제는 최대 크기의 독립 집합을 찾는 문제이다.
- 클리크(Clique)
    + 주어진 그래프에서 모든 점들 사이를 연결하는 선분이 있는 부분 그래프이다.(완전 그래프를 찾는다) 클리크 문제는 최대 크기의 클리크를 찾는 문제이다.
- 그래프 색칠하기(Graph Coloring)
    + 주어진 그래프에서 인접한 점들을 서로 다른 색으로 색칠하는 것이다. 그래프 색칠하기 문제는 가장 적은 수의 색을 사용하여 그래프를 색칠하는 문제이다.
- 집합 커버(Set Cover)
    + 주어진 집합 S={1,2,3,...,n}에 대해서 S의 부분 집합들이 주어질 떄, 이 부분 집합들 중에서 합집합하여 S와 같게 되는 부분 집합들을 집합 커버라고 한다. 집합 커버 문제는 가장 적은 수의 부분 집합으로 이루어진 집합 커버를 찾는 문제이다.
- 최장 경로(Longest Path)
    + 주어진 가중치 그래프에서 시작점 s에서 도착점 t까지의 가장 긴 경로를 찾는 문제. 단, 선분의 가중치는 양수이고, 싸이클이 없어야 한다.
- 여행자(Traveling Salesman) 문제
    + 주어진 가중치 그래프에서 , 임의의 한 점에서 출발하여, 다른 모든 점들을 1번씩만 방문하고, 다시 시작점으로 돌아오는 경로 중에서 최단 경로를 찾는 문제.
- 헤밀토니안 사이클(Hamiltonian Cycle)
    + 주어진 그래프에서, 임의의 한 점에서 출발하여 다른 점들을 1번씩만 방문하고, 다시 시작점으로 돌아오는 경로를 찾는 문제이다.
    + 선분의 가중치를 모두 동일하게 하여 여행자 문제의 해를 찾았을 때, 그 해가 헤밀토니안 사이클 문제의 해가 된다.
- 통 채우기(Bin Packing)
    + n개의 물건이 주어지고, 통(bin)의 용량이 c일 때, 가장 적은 수의 통을 사요아여 모든 물건을 통에 채우는 문제이다. 단, 각 물건의 크기는 C보다 크지 않다.
- 작업 스케쥴링(Job Scheduling)
    + n개의 작업, 각 작업의 수행시간 t, 그리고 m개의 동일한 성능의 기계가 주어질 때, 모든 작업이 가장 빨리 종료되도록 작업을 기계에 배정하는 문제.

지금까지 소개한 NP-complete 문제는 다항식 시간에 하나의 문제에서 다른 문제로 변환 가능하다.

### 문제 제시: 최장 증가 수열의 길이는?
- 다음과 같이 어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있다.
    + 3, 2, 6, 4, 5, 1
- 이 배열 순서를 유지하면서 크기가 점진적으로 커지는 가장 긴 부분 수열의 길이는 얼마일까?
- 답: 2,4,5

1. Brute-force 접근 방법(모든 부분 집합 찾아서 계산): O(n)


